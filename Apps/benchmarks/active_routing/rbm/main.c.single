#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <getopt.h>
#include <hooks.h>

#include "rbm.h"

// Input/output data
#define TRAIN_FILE "data.txt"
#define TEST_FILE "data.txt"
#define OUTPUT_FILE "out.txt"

// Free parameters
#define DEBUG 0
#define K 5
#define LEARN_RATE 0.1
#define RAND rand_twister()

// Fixed constants



double **edges; // edges[v][h] = the edge between visible unit v and hidden unit h
int **trainingData;

int **testActuals;
int **testPredictions;

int users;
int test_users;
int movies;
int loops;
int num_hidden;
int num_visible;

static struct option long_options[] = {
  /* name, has_arg, flag, val */
  {"users", required_argument, NULL, 'u'},
  {"test_users", required_argument, NULL, 't'},
  {"movies", required_argument, NULL, 'm'},
  {"loops", required_argument, NULL, 'l'},
  {0,0,0,0}
};

void activateHiddenUnits(int visible[], int stochastic, int hidden[])
{
	// Calculate activation energy for hidden units
	double hiddenEnergies[num_hidden];
	int h;
	for (h = 0; h < num_hidden; h++)
	{
		// Get the sum of energies
		double sum = 0;
		int v;
    int count = 0;
		for (v = 0; v < num_visible + 1; v++) // remove the +1 if you want to skip the bias
		{
      // TODO: optimize with masking
			if (visible[v] != -1) {
        ++count;
				//sum += (double) visible[v] * edges[v][h];
        UpdateII(&visible[v], &edges[v][h], &hiddenEnergies[h], MULT);
      }
		}
		//hiddenEnergies[h] = sum;
    if (count != 0)
      Gather(NULL, NULL, &hiddenEnergies[h], 1);
	}

	// Activate hidden units
	for (h = 0; h < num_hidden; h++)
	{
		double prob = 1.0 / (1.0 + exp(-hiddenEnergies[h]));
		if (stochastic)
		{
			if (RAND < prob)
				hidden[h] = 1;
			else
				hidden[h] = 0;
		}
		else
		{
			if (prob > 0.5)
				hidden[h] = 1;
			else
				hidden[h] = 0;
		}
	}

	hidden[num_hidden] = 1; // turn on bias
}


void activateVisibleUnits(int hidden[], int stochastic, int visible[])
{
	// Calculate activation energy for visible units
	double visibleEnergies[num_visible];
	int v;
  int count;
	for (v = 0; v < num_visible; v++)
	{
		// Get the sum of energies
		double sum = 0;
		int h;
    count = 0;
    int stride = CACHELINE_SIZE / sizeof(int);
		for (h = 0; h < num_hidden + 1 - stride; h += stride) { // remove the +1 if you want to skip the bias
			//sum += (double) hidden[h] * edges[v][h];
      ++count;
      UpdateRR(&hidden[h], &edges[v][h], &visibleEnergies[v], MULT);
    }
    // dealing with fragmentation, TODO: optimize it by applying masking
    for (; h < num_hidden + 1; h++) {
      ++count;
      UpdateII(&hidden[h], &edges[v][h], &visibleEnergies[v], MULT);
    }
		//visibleEnergies[v] = sum;
    if (count != 0)
      Gather(NULL, NULL, &visibleEnergies[v], 1);
	}

	// Activate visible units, handles K visible units at a time
	for (v = 0; v < num_visible; v += K)
	{
		double exps[K]; // this is the numerator
		double sumOfExps = 0.0; // this is the denominator

		int j;
    count = 0;
    int stride = CACHELINE_SIZE / sizeof(int);
		for (j = 0; j < K - stride; j += stride)
		{
			//exps[j] = exp(visibleEnergies[v + j]);
			//sumOfExps += exps[j];
      ++count;
      UpdateRR( &visibleEnergies[v + j], NULL, &sumOfExps, ADD); // XXX: treat exponential-and-accumulate as ADD
		}
    // dealing with fragmentation, TODO: optimize it by applying masking
    for (; j < K; j++) {
      ++count;
      UpdateII( &visibleEnergies[v + j], NULL, &sumOfExps, ADD); // XXX: treat exponential-and-accumulate as ADD
    }
    if (count != 0)
      Gather(NULL, NULL, &sumOfExps, 1); //TODO: this may have problem in CasHMC, since sumOfExps is reuse for differnt flows

		// Getting the probabilities

		double probs[K];

		for (j = 0; j < K; j++)
			probs[j] = exps[j] / sumOfExps;

		// Activate units

		if (stochastic) // used for training
		{
			for (j = 0; j < K; j++)
			{
				if (RAND < probs[j])
					visible[v + j] = 1;
				else
					visible[v + j] = 0;
			}
		}
		else // used for prediction: uses expectation
		{

      //count = 0;
			double expectation = 0.0;
			for (j = 0; j < K; j++) {
				expectation += j * probs[j]; // we will predict rating between 0 to K-1, not between 1 to K
        //++count;
        //UpdateRR(&j, &probs[j], &expectation, MULT);
      }
      //if (count != 0)
      //  Gather(NULL, NULL, &expectation, 1);

			long prediction = round(expectation);

			for (j = 0; j < K; j++)
			{
				if (j == prediction)
					visible[v + j] = 1;
				else
					visible[v + j] = 0;
			}
		}
	}

	visible[num_visible] = 1; // turn on bias
}

void train()
{
	int user;
	for (user = 0; user < users; user++)
	{
		// ==> Phase 1: Activate hidden units

		int data[num_visible + 1];
		memcpy(data, trainingData[user], num_visible * sizeof(int)); // copy entire array
		data[num_visible] = 1; // turn on bias

		// Activate hidden units
		int hidden[num_hidden + 1];
		activateHiddenUnits(data, 1, hidden);

    if (DEBUG) {
      int i;
      printf("user %d\n\tdata:\n\t", user);
      for (i = 0; i < num_visible + 1; i++) {
        printf("%d ", data[i]);
      }
      printf("\n\thidden:\n\t");
      for (i = 0; i < num_hidden + 1; i++) {
        printf("%d ", hidden[i]);
      }
    }

		// Get positive association
		int pos[num_visible + 1][num_hidden + 1];
		int v;
		for (v = 0; v < num_visible + 1; v++)
		{
			if (data[v] != -1)
			{
				int h;
				for (h = 0; h < num_hidden + 1; h++)
					pos[v][h] = data[v] * hidden[h];
			}
      else
      {
				int h;
				for (h = 0; h < num_hidden + 1; h++)
					pos[v][h] = 0;
      }
		}

    if (DEBUG) {
      int i, j;
      printf("\tpos:\n\t");
      for (i = 0; i < num_visible + 1; i++) {
        if (data[i] != -1) {
          for (j = 0; j < num_hidden + 1; j++)
            printf("%d ", pos[i][j]);
          printf("\n");
          if (i < num_visible)
            printf("\t");
        }
      }
    }

		// ==> Phase 2: Reconstruction (activate visible units)

		// Activate visible units
		int visible[num_visible + 1];
		activateVisibleUnits(hidden, 1, visible);

    if (DEBUG) {
      int i;
      printf("\tvisible:\n\t");
      for (i = 0; i < num_visible + 1; i++)
        printf("%d ", visible[i]);
      printf("\n");
    }

		// Get negative association
		int neg[num_visible + 1][num_hidden + 1];
		for (v = 0; v < num_visible + 1; v++)
		{
			if (data[v] != -1)
			{
				int h;
				for (h = 0; h < num_hidden + 1; h++)
					neg[v][h] = hidden[h] * visible[v];
			}
      else
      {
				int h;
				for (h = 0; h < num_hidden + 1; h++)
					neg[v][h] = 0;
      }
		}

    if (DEBUG) {
      int i, j;
      printf("\tneg:\n\t");
      for (i = 0; i < num_visible + 1; i++) {
        for (j = 0; j < num_hidden + 1; j++)
          printf("%d ", neg[i][j]);
        printf("\n");
        if (i < num_visible)
          printf("\t");
      }
    }

		// ==> Phase 3: Update the weights
		for (v = 0; v < num_visible + 1; v++)
		{
			int h;
			for (h = 0; h < num_hidden + 1; h++)
				edges[v][h] = edges[v][h] + LEARN_RATE * (pos[v][h] - neg[v][h]);
		}
	}
}

void processLine(int target[], FILE * stream, int optActual[])
{
	int j;
	for (j = 0; j < num_visible; j += K)
	{
		int rating = 0;
		if(fscanf(stream, "%d", &rating) != 1 ) {
      printf("ERROR: Failed to read stream");
    }
		if (optActual != NULL)
			optActual[j / K] = rating;

		int k;
		for (k = 0; k < K; k++)
		{
			if (rating <= 0)
				target[j + k] = -1; // missing rating
			else if (rating == k + 1)
				target[j + k] = 1;
			else
				target[j + k] = 0;
		}
	}
}

int main(int argc, char *argv[])
{
  // parse options
  int opt, option_index = 0;
  while((opt = getopt_long(argc, argv, "u:t:m:l:",
                        long_options, &option_index)) != -1) {
    switch (opt) {
      case 'u':
        users = atoi(optarg);
        break;
      case 't':
        test_users = atoi(optarg);
        break;
      case 'm':
        movies = atoi(optarg);
        break;
      case 'l':
        loops = atoi(optarg);
        break;
      case ':':
        fprintf(stderr, "missing argument\n");
        break;
      case '?':
        fprintf(stderr, "invalid option\n");
        break;
      default:
        fprintf(stderr,
                "Usage: %s -u #users -t #test_users -m #movies -l #loops\n",
                argv[0]);
        fprintf(stderr,
                "   OR: %s -users #users -test_users #test_users -movies #movies -loops #loops\n",
                argv[0]);
        exit(1);
    }
  }
  num_hidden = 3 * movies;
  num_visible = K * movies;
  fprintf(stderr, "users: %d, test_users: %d, movies: %d, loops: %d, num_hidden: %d, num_visible: %d\n",
          users, test_users, movies, loops, num_hidden, num_visible);

  if ((optind < argc) || (optind == 1)) {
    fprintf(stderr,
            "Usage: %s -u #users -t #test_users -m #movies -l #loops\n",
            argv[0]);
    fprintf(stderr,
            "   OR: %s -users #users -test_users #test_users -movies #movies -loops #loops\n",
            argv[0]);
    exit(1);
  }

  // allocate memory for global arrays
  int u;
  //edges = (double **) calloc(num_visible + 1, sizeof(double *));
  if (posix_memalign((void **) &edges, CACHELINE_SIZE, (num_visible + 1) * sizeof(double *))) {
    fprintf(stderr, "Memory allocation for edges fail\n");
    exit(1);
  }
  for (u = 0; u < num_visible + 1; u++) {
    if (posix_memalign((void **) &edges[u], CACHELINE_SIZE, (num_hidden + 1) * sizeof(double))) {
      fprintf(stderr, "Memory allocation for edges[%d] fail\n", u);
      exit(1);
    }
    memset(edges[u], 0, (num_hidden + 1) * sizeof(double));
    //edges[u] = (double *) calloc(num_hidden + 1, sizeof(double));
  }

  //trainingData = (int **) calloc(users, sizeof(int *));
  if (posix_memalign((void **) &trainingData, CACHELINE_SIZE, users * sizeof(int *))) {
    fprintf(stderr, "Memory allocation for trainingData fail\n");
    exit(1);
  }
  for (u = 0; u < users; u++) {
    //trainingData[u] = (int *) calloc(num_visible, sizeof(int));
    if (posix_memalign((void **) &trainingData[u], CACHELINE_SIZE, num_visible * sizeof(int))) {
      fprintf(stderr, "Memory allocation for trainingData[%d] fail\n", u);
      exit(1);
    }
    memset(trainingData[u], 0, num_visible * sizeof(int));
  }

  //testActuals = (int **) calloc(test_users, sizeof(int *));
  if (posix_memalign((void **) &testActuals, CACHELINE_SIZE, test_users * sizeof(int *))) {
    fprintf(stderr, "Memory allocation for testActuals fail\n");
    exit(1);
  }
  for (u = 0; u < test_users; u++) {
    //testActuals[u] = (int *) calloc(movies, sizeof(int));
    if (posix_memalign((void **) &testActuals[u], CACHELINE_SIZE, movies * sizeof(int))) {
      fprintf(stderr, "Memory allocation for testActuals[%d] fail\n", u);
      exit(1);
    }
    memset(testActuals[u], 0, movies * sizeof(int));
  }

  //testPredictions = (int **) calloc(test_users, sizeof(int *));
  if (posix_memalign((void **) &testPredictions, CACHELINE_SIZE, test_users * sizeof(int *))) {
    fprintf(stderr, "Memory allocation for testPredictions fail\n");
    exit(1);
  }
  for (u = 0; u < test_users; u++) {
    //testPredictions[u] = (int *) calloc(movies, sizeof(int));
    if (posix_memalign((void **) &testPredictions[u], CACHELINE_SIZE, movies * sizeof(int))) {
      fprintf(stderr, "Memory allocation for testActuals[%d] fail\n", u);
      exit(1);
    }
    memset(testPredictions[u], 0, movies * sizeof(int));
  }

  //**Timing**/
  unsigned int* start, *stop, *elapsed;
	// -------- Preparing training data ---------

	FILE *trainingFile = fopen(TRAIN_FILE, "r");
	int i, j, k;
	for (i = 0; i < users; i++)
	{
		processLine(trainingData[i], trainingFile, NULL);
	}

	fclose(trainingFile);


	// -------- Training ---------

    
  roi_begin(); 
	int loop;
	for (loop = 0; loop < loops; loop++)
	{
		if (DEBUG)
		    printf("Loop: %d\n", loop);
		train();
	}

	if (0)
	{
		// Print weights

		for (i = 0; i < num_visible + 1; i++)
		{
			for (j = 0; j < num_hidden + 1; j++)
				printf("%5.2f ", edges[i][j]);

			printf("\n");
		}
	}

	// -------- Testing ---------


	FILE *testFile = fopen(TEST_FILE, "r");
	FILE *outputFile = fopen(OUTPUT_FILE, "w");


	int user;
	for (user = 0; user < test_users; user++)
	{
		int data[num_visible + 1];
		processLine(data, testFile, testActuals[user]);
		data[num_visible] = 1; // turn on bias

		int tmp[num_hidden + 1];
		activateHiddenUnits(data, 0, tmp);
		int result[num_visible + 1];
		activateVisibleUnits(tmp, 0, result);


		// Go through K visible units at a time
		for (i = 0; i < num_visible; i += K)
		{
			int prediction = 0;

			for (j = 0; j < K; j++)
			{
				if (result[i + j] == 1)
				{
					if (prediction == 0)
						prediction = j+1;
					else
					{
						printf("ERROR! Found more than one 1s in the same movie\n");
						exit(1);
					}
				}
			}

			if (prediction == 0)
			{
				printf("ERROR! No prediction was made for this movie!\n");
				exit(1);
			}
			testPredictions[user][i / K] = prediction;
		}
	}
  roi_end(); 

	fclose(testFile);
	// -------- Writing result ---------


	for (i = 0; i < test_users; i++)
	{
		for (j = 0; j < movies; j++)
			fprintf(outputFile, "%d ", testPredictions[i][j]);
		fprintf(outputFile, "\n");
	}

	fclose(outputFile);

  // free allocated memory
  for (i = 0; i < num_visible + 1; i++)
   free(edges[i]);
  free(edges);
  for (i = 0; i < users; i++)
    free(trainingData[i]);
  free(trainingData);
  for (i = 0; i < test_users; i++) {
    free(testActuals[i]);
    free(testPredictions[i]);
  }
  free(testActuals);
  free(testPredictions);

	return 0;

}
